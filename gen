#!/bin/sh
# shellcheck disable=SC2031

CONF_FILE=./conf

safe_replace() {
    DELIM=$(printf "\001") # Rare sed delimiter to avoid conflicts

    # Escape special characters in the replacement string to make it safe for sed
    REPLACE=$(printf "%s" "$2" | sed 's/[&/\]/\\&/g')

    # Convert newlines into a placeholder sequence (e.g., '\n')
    REPLACE=$(printf "%s" "$REPLACE" | sed ':a;N;$!ba;s/\n/\\n/g')

    # Ensure REPLACE is not empty
    if [ -z "$REPLACE" ]; then
        printf "Skipping replacement for placeholder \"%s\" because the replacement value is empty or invalid.\n" "$1"
        return
    fi

    # Replace the placeholder in the file using sed
    sed -i "s$DELIM\${$1}$DELIM$REPLACE$DELIM g" "$BUILD_DIR/$file_name"
}

get_git_info() {
    target="$1"

    # Get the commit logs.
    git_info=$(git log --format='%ad|%h|%an|%s' --date=rfc -- "$target")

    git_creation_info=$(echo "$git_info" | tail -n 1)
    git_modification_info=$(echo "$git_info" | head -n 1)

    git_creation_hash=$(echo "$git_creation_info" | cut -d'|' -f2)
    git_creation_date=$(echo "$git_creation_info" | cut -d'|' -f1)

    git_modification_hash=$(echo "$git_modification_info" | cut -d'|' -f2)
    git_modification_date=$(echo "$git_modification_info" | cut -d'|' -f1)

    # shellcheck disable=SC2034
    git_creation_author=$(echo "$git_creation_info" | cut -d'|' -f3)
    # shellcheck disable=SC2034
    git_modification_author=$(echo "$git_modification_info" | cut -d'|' -f3)

    commit_base_url="https://github.com/$GITHUB_USER/$GITHUB_REPO/commit"
    # shellcheck disable=SC2034
    git_creation_commit_link="$commit_base_url/$git_creation_hash"
    # shellcheck disable=SC2034
    git_modification_commit_link="$commit_base_url/$git_modification_hash"

    # Generate all commits list with newline after each entry
    all_commits=$(echo "$git_info" | while IFS='|' read -r commit_date commit_hash commit_author commit_message; do
        commit_url="$commit_base_url/$commit_hash"
        printf "<li><time datetime=\"%s\">%s</time> &ndash; <strong>%s</strong>: <a target=\"_blank\" href=\"%s\">%s</a></li>\n" \
            "$commit_date" "$commit_date" "$commit_author" "$commit_url" "$commit_message"
    done)
}

# Function to check if a command exists
check_command() {
    cmd="$1"
    command -v "$cmd" > /dev/null 2>&1 || {
        printf "Error: %s is not installed or not in PATH. Please install it before running the script.\n" "$cmd"
        exit 1
    }
}

# List of required commands
required_commands="jq pandoc curl git sed awk realpath"

# Dynamically check each command
for cmd in $required_commands; do
    check_command "$cmd"
done

# shellcheck disable=SC2015
# shellcheck source=./conf
[ -f "$CONF_FILE" ] && . "$CONF_FILE" || {
    printf "ERROR: Configuration file (%s) not found. Exiting.\n" "$CONF_FILE"
    exit 1
}

# Ensure critical variables are set
BUILD_DIR=${BUILD_DIR:-"./build"}
CSS_FILE=${CSS_FILE:-"./style.css"}
PICS_DIR=${PICS_DIR:-"./pics"}

# Ensure 'to_build' is set and not empty
[ -z "${to_build:-}" ] && {
    printf "ERROR: The 'to_build' variable is not set in the configuration file. Exiting.\n"
    exit 1
}

[ -d "$BUILD_DIR" ] && rm -rf "$BUILD_DIR" # Delete build dir if exist
mkdir -p "$BUILD_DIR"

for file in $(printf "%s" "$to_build" | sed '/^$/d'); do
    ( # Subshell to maintain file-specific variables.
        file=$(realpath "$file")
        file_name=$(basename "$file")
        file_ext="${file_name##*.}"
        file_wext=${file_name%.*}

        [ ! -d "$file" ] && {
            printf "ERROR: %s doesn't exist.\n" "$file"
            exit 1
        }

        touch "$BUILD_DIR/$file_name"

        printf "Started generating => %s/%s\n" "$BUILD_DIR" "$file_name"

        # Source file-specific conf
        [ -f "$file/conf" ] && . "$file/conf"

        # Write default header.
        [ "$file_ext" = "html" ] && { [ -z "$add_header" ] || [ "$add_header" = "true" ]; } && cat "$(realpath "$default_header")" >> "$BUILD_DIR/$file_name"

        # Write ext files if exist
        for ext_file in "$file"/*."$file_ext"; do
            cat "$ext_file" >> "$BUILD_DIR/$file_name"
        done

        # Convert and write markdown file if `is_markdown` is true
        [ "$file_ext" = "html" ] && [ -n "$is_markdown" ] && [ "$is_markdown" = "true" ] && {
            for md in "$(realpath "$file")"/*.md; do
                converted_md=$(pandoc "$md")
                printf "%s\n" "$converted_md" \
                    | sed -i "/<!-- MARKDOWN -->/r /dev/stdin" "$BUILD_DIR/$file_name"
                printf "Markdown file %s successfully converted to HTML using Pandoc and aggregated into %s\n" "$BUILD_DIR/$file_name" "$md"
            done
        }

        for css in "$(realpath "$file")"/*.css; do
            [ -f "$css" ] || continue # Skip if no CSS files found
            cat "$css" >> "$BUILD_DIR/$file_wext.css"
            sed -i "/<head>/a \    <link rel=\"stylesheet\" type=\"text/css\" href=\"$file_wext.css\">" "$BUILD_DIR/$file_name"
            printf "Aggregated %s into %s\n" "$css" "$BUILD_DIR/$file_wext.css"
        done

        # Write default footer.
        [ "$file_ext" = "html" ] && { [ -z "$add_footer" ] || [ "$add_footer" = "true" ]; } && cat "$(realpath "$default_footer")" >> "$BUILD_DIR/$file_name"

        # Extract placeholders using grep, then remove the `${}` and sort uniquely
        placeholders=$(grep -o "\${\([^}]*\)}" "$BUILD_DIR/$file_name" | sed 's/[${}]//g' | sort -u)

        # Get git info
        get_git_info "$file_name"

        for key in $placeholders; do
            eval val=\$"$key"

            # Handle git-derived values or warn about undefined placeholders
            case "$key" in
                date_created | date_updated)
                    [ -z "$val" ] && {
                        val=$([ "$key" = "date_created" ] && printf "%s" "$git_creation_date" || printf "%s" "$git_modification_date")
                        log_msg=$([ "$key" = "date_created" ] && printf "%s" "creation date" || printf "%s" "modification date")
                        printf "Replacing placeholder/key \"%s\" with git-derived %s => \"%s\" in %s (value not available in config to override)\n" "$key" "$log_msg" "$val" "$file_name"
                    }
                    ;;
                *)
                    [ -z "$val" ] && printf "WARNING: Placeholder \"%s\" has no value.\n" "$key"
                    ;;
            esac

            # Replace the placeholder in the file
            printf "Replacing placeholder/key \"%s\" with value => \"%s\" in %s\n" "$key" "$val" "$file_name"
            safe_replace "$key" "$val" "$BUILD_DIR/$file_name"
        done

        # Link files to index.html and RSS if enabled
        link_index=${link_index:-"false"}
        link_rss=${link_rss:-"false"}
        date_created=${date_created:-""}
        title=${title:-"Untitled"}

        [ "$file_name" != "index.html" ] && [ "$link_index" = "true" ] && {
            sed -i "/^    <!-- POSTS -->/a <li><time datetime=\"$date_created\">$date_created</time> &ndash; <a href=\"$file_name\">$title</a></li>" "$BUILD_DIR/index.html"
            printf "File linked in index.html => %s\n" "$site_url/$file_name"
        }

        [ "$file_name" != "rss.xml" ] && [ "$link_rss" = "true" ] && {
            sed -i "/^<!-- POSTS -->/a <item>\n<title>$title</title>\n<guid>$site_url/$file_name</guid>\n<pubDate>$date_created</pubDate>\n<link>$site_url/$file_name</link>\n<description>${description:-""}</description>\n</item>" "$BUILD_DIR/rss.xml"
            printf "File linked in RSS feed => %s\n" "$site_url/$file_name"
        }

        printf "Finished generating %s\n\n" "$BUILD_DIR/$file_name"
    ) # Subshell to maintain file-specific variables.
done

# This will get info for the whole repository.
get_git_info "."

repo_commits=$(printf "%s" "$all_commits" | head -n "$COMMITS_NUM")

# Create a temporary file with the commit list
tmp_file=$(mktemp)
printf "%s\n" "$repo_commits" > "$tmp_file"

# Append the contents of the temporary file to index.html after the matching line
sed -i "/^    <!-- GIT -->/r $tmp_file" "$BUILD_DIR/index.html"

# Clean up the temporary file
rm -f "$tmp_file"

# Copy CSS and images
cp "$CSS_FILE" "$BUILD_DIR"
cp -r "$PICS_DIR" "$BUILD_DIR"

#!/bin/sh
# shellcheck disable=SC2031

# Note: This does not resolve symlinks
posix_realpath() {
    [ -z "$1" ] && return 1 # Check if input is provided
    (
        cd "$(dirname "$1")" || exit 1 # Change to the directory of the input
        echo "$PWD/$(basename "$1")"   # Combine the absolute path with the basename
    )
}

extract_placeholders() {
    target_file="$1"
    placeholders=""

    while IFS= read -r line || [ -n "$line" ]; do
        # Extract all occurrences of ${...} in the line
        while :; do
            case "$line" in
                *\$\{*\}*)
                    # Extract the first placeholder
                    before=${line%%\$\{*}
                    after=${line#*\$\{}
                    placeholder=${after%%\}*}

                    # Append to placeholders list
                    placeholders="$placeholders $placeholder"

                    # Remove the processed placeholder from the line
                    line=${after#*\}}
                    ;;
                *)
                    break
                    ;;
            esac
        done
    done < "$target_file"

    # Remove duplicates and sort
    printf "%s" "$placeholders" | tr ' ' '\n' | sort | uniq
}

# Function to replace or append <!-- %s --> comments and ${x} placeholdesrs.
replace() {
    target_file="$1"
    content="$2"
    replacement="$3"
    append="$4"

    temp_file=$(mktemp)

    # Use a single loop to process lines
    while IFS= read -r line; do
        # Check if the line contains the comment
        case "$line" in
            *"<!-- $content -->"*)
                printf "%s\n" "$line" >> "$temp_file"
                [ "$append" = "true" ] && printf "%s\n" "$replacement" >> "$temp_file" || printf "%s\n" "$replacement" >> "$temp_file"
                ;;
            *"\${$content}"*)
                # Initialize variables for replacement
                modified_line=""
                remaining="$line"

                # Loop to replace all occurrences of ${content}
                while :; do
                    case "$remaining" in
                        *"\${$content}"*)
                            # Extract text before the placeholder
                            before=${remaining%%"\${$content}"*}
                            # Extract text after the placeholder
                            after=${remaining#*"\${$content}"}
                            # Append the part before and the replacement to modified_line
                            modified_line="${modified_line}${before}${replacement}"
                            # Update remaining to the part after the placeholder
                            remaining="$after"
                            ;;
                        *)
                            # No more placeholders; append the rest of the line
                            modified_line="${modified_line}${remaining}"
                            break
                            ;;
                    esac
                done

                # Write the modified line to the temp file
                printf "%s\n" "$modified_line" >> "$temp_file"
                ;;
            *)
                printf "%s\n" "$line" >> "$temp_file"
                ;;
        esac
    done < "$target_file"

    mv "$temp_file" "$target_file"
    printf "Replaced or appended to \"<!-- %s -->\" in %s\n" "$content" "$target_file"
}

get_git_info() {
    target="$1"

    # Get git logs for the target
    git_info=$(git log --format='%ad|%h|%an|%s' --date=rfc -- "$target")

    git_creation_info=$(printf "%s" "$git_info" | tail -n 1)
    git_modification_info=$(printf "%s" "$git_info" | head -n 1)

    git_creation_hash=$(printf "%s" "$git_creation_info" | cut -d'|' -f2)
    git_creation_date=$(printf "%s" "$git_creation_info" | cut -d'|' -f1)

    git_modification_hash=$(printf "%s" "$git_modification_info" | cut -d'|' -f2)
    git_modification_date=$(printf "%s" "$git_modification_info" | cut -d'|' -f1)

    # shellcheck disable=SC2034
    git_creation_author=$(printf "%s" "$git_creation_info" | cut -d'|' -f3)
    # shellcheck disable=SC2034
    git_modification_author=$(printf "%s" "$git_modification_info" | cut -d'|' -f3)

    # Construct base URL
    commit_base_url="https://github.com/$GITHUB_USER/$GITHUB_REPO/commit"
    # shellcheck disable=SC2034
    git_creation_commit_link="$commit_base_url/$git_creation_hash"
    # shellcheck disable=SC2034
    git_modification_commit_link="$commit_base_url/$git_modification_hash"

    # Generate all commits list with newline after each entry
    all_commits=$(printf "%s" "$git_info" | while IFS='|' read -r commit_date commit_hash commit_author commit_message; do
        printf "<li><time datetime=\"%s\">%s</time> &ndash; <strong>%s</strong>: <a target=\"_blank\" href=\"%s\">%s</a></li>\n" \
            "$commit_date" "$commit_date" "$commit_author" "$commit_base_url/$commit_hash" "$commit_message"
    done)
}

# Function to check if a command exists
check_command() {
    cmd="$1"
    command -v "$cmd" > /dev/null 2>&1 || {
        printf "Error: %s is not installed or not in PATH. Please install it before running the script.\n" "$cmd"
        exit 1
    }
}

# Function to check if a variable is empty
check_var() {
    var_name="$1"
    # Use eval to fetch the value of the variable dynamically
    eval var_value=\$"$var_name"

    # Exit with an error message if the variable is empty
    [ -n "$var_value" ] || {
        printf "ERROR: The '%s' variable is not set or is empty. Exiting.\n" "$var_name"
        exit 1
    }
}

process_file() {
    file="$1"
    file=$(posix_realpath "$file")
    file_name=$(basename "$file")
    file_ext="${file_name##*.}"
    file_wext=${file_name%.*}

    # Check if file is a directory
    if [ ! -d "$file" ]; then
        printf "ERROR: %s doesn't exist.\n" "$file"
        return 1
    fi

    touch "$BUILD_DIR/$file_name"

    printf "Started generating => %s/%s\n" "$BUILD_DIR" "$file_name"

    # Source file-specific conf
    [ -f "$file/conf" ] && . "$file/conf"

    # Write default header if applicable
    if [ "$file_ext" = "html" ]; then
        # shellcheck disable=SC2154
        if [ "$add_header" != "false" ] && [ -f "$default_header" ]; then
            cat "$(posix_realpath "$default_header")" >> "$BUILD_DIR/$file_name"
        else
            printf "ERROR: The default header file '%s' does not exist. Exiting.\n" "$default_header"
            return 1
        fi
    fi

    # Write extension files if they exist
    for ext_file in "$file"/*."$file_ext"; do
        [ -e "$ext_file" ] || continue
        printf "Appending content from %s to %s\n" "$ext_file" "$BUILD_DIR/$file_name"
        cat "$ext_file" >> "$BUILD_DIR/$file_name" 2> /dev/null || printf "WARNING: No such file %s found\n" "$ext_file"
    done

    # Convert markdown to html if applicable
    if [ "$file_ext" = "html" ] && [ -n "$is_markdown" ] && [ "$is_markdown" = "true" ]; then
        for md in "$file"/*.md; do
            [ -e "$md" ] || continue
            converted_md=$(cmark-gfm --extension table "$md")
            # Replace or append the converted markdown content after the <!-- MARKDOWN --> comment
            replace "$BUILD_DIR/$file_name" "MARKDOWN" "$converted_md" "true"
            printf "Markdown file %s successfully converted to HTML using cmark-gfm and aggregated into %s\n" "$md" "$BUILD_DIR/$file_name"
        done
    fi

    # Aggregate CSS files
    if [ "$file_ext" = "html" ]; then
        ls "$file"/*.css > /dev/null 2>&1 && cat "$file"/*.css >> "$BUILD_DIR/$file_wext.css"

        # Generate the <link> tag for inclusion in the HTML
        stylesheet="<link rel=\"stylesheet\" type=\"text/css\" href=\"$file_wext.css\">"

        # Replace the placeholder in the HTML file
        replace "$BUILD_DIR/$file_name" "HEAD" "$stylesheet" "true"

        # Log the aggregation process
        printf "Aggregated CSS files into %s\n" "$BUILD_DIR/$file_wext.css"
    fi

    # Link file to index.html if link_index is true and file_name is not index.html
    [ "$file_name" != "index.html" ] && [ "$link_index" = "true" ] && {
        # Prepare the content to append to the <!-- POSTS --> comment in index.html
        # shellcheck disable=SC2154
        post_content="<li><time datetime=\"$date_created\">$date_created</time> &ndash; <a href=\"$file_name\">$title</a></li>"

        # Use replace to append the post content after the <!-- POSTS --> comment in index.html
        replace "$BUILD_DIR/index.html" "POSTS" "$post_content" "true"
        printf "File linked in index.html => %s\n" "$site_url/$file_name"
    }

    # Link file to rss.xml if link_rss is set to true
    [ "$file_name" != "rss.xml" ] && [ "$link_rss" = "true" ] && {
        # Prepare the content to append to the <!-- POSTS --> comment in rss.xml
        rss_content="<item><title>$title</title><guid>$site_url/$file_name</guid><pubDate>$date_created</pubDate><link>$site_url/$file_name</link><description>${description:-""}</description></item>"

        # Use replace to append the rss content after the <!-- POSTS --> comment in rss.xml
        replace "$BUILD_DIR/rss.xml" "POSTS" "$rss_content" "true"
        printf "File linked in RSS feed => %s\n" "$site_url/$file_name"
    }

    # Write default footer if applicable
    if [ "$file_ext" = "html" ] && { [ -z "$add_footer" ] || [ "$add_footer" = "true" ]; }; then
        cat "$(posix_realpath "$default_footer")" >> "$BUILD_DIR/$file_name"
    fi

    # Extract and process placeholders
    placeholders=$(extract_placeholders "$BUILD_DIR/$file_name")

    # Get git info
    get_git_info "$file_name"

    for key in $placeholders; do
        eval val=\$"$key"

        # Handle git-derived values or warn about undefined placeholders
        case "$key" in
            # If not set explicitly, get from Git metadata
            date_created | date_updated)
                if [ -z "$val" ]; then
                    if [ "$key" = "date_created" ]; then
                        val="$git_creation_date"
                        log_msg="creation date"
                    else
                        val="$git_modification_date"
                        log_msg="modification date"
                    fi
                    printf "Replacing placeholder/key \"%s\" with git-derived %s => \"%s\" in %s (value not available in config to override)\n" "$key" "$log_msg" "$val" "$file_name"
                fi
                ;;
            *)
                if [ -z "$val" ]; then
                    printf "WARNING: Placeholder \"%s\" has no value.\n" "$key"
                fi
                ;;
        esac

        # Replace the placeholder in the file
        printf "Replacing placeholder/key \"%s\" with value => \"%s\" in %s\n" "$key" "$val" "$file_name"
        replace "$BUILD_DIR/$file_name" "$key" "$val" "false"
    done

    # Prepare shared resource updates
    if [ "$file_name" != "index.html" ]; then
        if [ "$link_index" = "true" ]; then
            post_content="<li><time datetime=\"$date_created\">$date_created</time> &ndash; <a href=\"$file_name\">$title</a></li>"
            echo "$post_content" >> "$BUILD_DIR/posts_updates.txt"
            printf "File linked in index.html => %s\n" "$site_url/$file_name"
        fi

        if [ "$file_name" != "rss.xml" ] && [ "$link_rss" = "true" ]; then
            rss_content="<item><title>$title</title><guid>$site_url/$file_name</guid><pubDate>$date_created</pubDate><link>$site_url/$file_name</link><description>${description:-""}</description></item>"
            echo "$rss_content" >> "$BUILD_DIR/rss_updates.txt"
            printf "File linked in RSS feed => %s\n" "$site_url/$file_name"
        fi
    fi

    printf "Finished generating %s\n\n" "$BUILD_DIR/$file_name"
}

# List of required commands
required_commands="cmark-gfm git"

# Dynamically check each command
for cmd in $required_commands; do
    check_command "$cmd"
done

CONF_FILE=./conf
# shellcheck source=./conf
# shellcheck disable=SC2015
[ -f "$CONF_FILE" ] && . "$CONF_FILE" || {
    printf "ERROR: Configuration file (%s) not found. Exiting.\n" "$CONF_FILE"
    exit 1
}

# List of required variables
required_vars="BUILD_DIR CSS_FILE PICS_DIR GITHUB_REPO GITHUB_USER to_build default_header default_footer"

# Dynamically check each variable
for var in $required_vars; do
    check_var "$var"
done

[ -d "$BUILD_DIR" ] && rm -rf "$BUILD_DIR" # Delete build dir if it exists.
mkdir -p "$BUILD_DIR"

printf "%s" "$to_build" | while IFS= read -r file; do
    # Skip empty lines
    [ -n "$file" ] || continue
    # TODO: There is an opportunity to implement parallelism here.
    ( # Subshell to maintain file-specific variables.
        process_file "$file"
    ) # Subshell to maintain file-specific variables.
done

# This will get info for the whole repository.
get_git_info "."

# Replace comment in index.html with commit info
replace "$BUILD_DIR/index.html" "GIT" "$(printf "%s" "$all_commits" | head -n "$COMMITS_NUM")" "true"

# Copy CSS and images
cp "$CSS_FILE" "$BUILD_DIR"
cp -R "$PICS_DIR" "$BUILD_DIR"

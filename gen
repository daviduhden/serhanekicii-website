#!/bin/sh
# shellcheck disable=SC2031

extract_placeholders() {
    target_file="$1"
    placeholders=""

    while IFS= read -r line || [ -n "$line" ]; do
        # Extract all occurrences of ${...} in the line
        while :; do
            case "$line" in
                *\$\{*\}*)
                    # Extract the first placeholder
                    before=${line%%\$\{*}
                    after=${line#*\$\{}
                    placeholder=${after%%\}*}

                    # Append to placeholders list
                    placeholders="$placeholders $placeholder"

                    # Remove the processed placeholder from the line
                    line=${after#*\}}
                    ;;
                *)
                    break
                    ;;
            esac
        done
    done < "$target_file"

    # Remove duplicates and sort
    printf "%s" "$placeholders" | tr ' ' '\n' | sort | uniq
}

# Function to replace or append <!-- %s --> comments and ${x} placeholdes, without sed.
replace() {
    target_file="$1"
    content="$2"
    replacement="$3"
    append="$4"

    temp_file=$(mktemp)

    # Use a single loop to process lines
    while IFS= read -r line; do
        # Check if the line contains the comment
        case "$line" in
            *"<!-- $content -->"*)
                printf "%s\n" "$line" >> "$temp_file"
                [ "$append" = "true" ] && printf "%s\n" "$replacement" >> "$temp_file" || printf "%s\n" "$replacement" >> "$temp_file"
                ;;
            *"\${$content}"*)
                # Initialize variables for replacement
                modified_line=""
                remaining="$line"

                # Loop to replace all occurrences of ${content}
                while :; do
                    case "$remaining" in
                        *"\${$content}"*)
                            # Extract text before the placeholder
                            before=${remaining%%"\${$content}"*}
                            # Extract text after the placeholder
                            after=${remaining#*"\${$content}"}
                            # Append the part before and the replacement to modified_line
                            modified_line="${modified_line}${before}${replacement}"
                            # Update remaining to the part after the placeholder
                            remaining="$after"
                            ;;
                        *)
                            # No more placeholders; append the rest of the line
                            modified_line="${modified_line}${remaining}"
                            break
                            ;;
                    esac
                done

                # Write the modified line to the temp file
                printf "%s\n" "$modified_line" >> "$temp_file"
                ;;
            *)
                printf "%s\n" "$line" >> "$temp_file"
                ;;
        esac
    done < "$target_file"

    mv "$temp_file" "$target_file"
    printf "Replaced or appended to \"<!-- %s -->\" in %s\n" "$content" "$target_file"
}

get_git_info() {
    target="$1"

    # Get git logs for the target
    git_info=$(git log --format='%ad|%h|%an|%s' --date=rfc -- "$target")

    git_creation_info=$(printf "%s" "$git_info" | tail -n 1)
    git_modification_info=$(printf "%s" "$git_info" | head -n 1)

    git_creation_hash=$(printf "%s" "$git_creation_info" | cut -d'|' -f2)
    git_creation_date=$(printf "%s" "$git_creation_info" | cut -d'|' -f1)

    git_modification_hash=$(printf "%s" "$git_modification_info" | cut -d'|' -f2)
    git_modification_date=$(printf "%s" "$git_modification_info" | cut -d'|' -f1)

    # shellcheck disable=SC2034
    git_creation_author=$(printf "%s" "$git_creation_info" | cut -d'|' -f3)
    # shellcheck disable=SC2034
    git_modification_author=$(printf "%s" "$git_modification_info" | cut -d'|' -f3)

    # Construct base URL
    commit_base_url="https://github.com/$GITHUB_USER/$GITHUB_REPO/commit"
    # shellcheck disable=SC2034
    git_creation_commit_link="$commit_base_url/$git_creation_hash"
    # shellcheck disable=SC2034
    git_modification_commit_link="$commit_base_url/$git_modification_hash"

    # Generate all commits list with newline after each entry
    all_commits=$(printf "%s" "$git_info" | while IFS='|' read -r commit_date commit_hash commit_author commit_message; do
        printf "<li><time datetime=\"%s\">%s</time> &ndash; <strong>%s</strong>: <a target=\"_blank\" href=\"%s\">%s</a></li>\n" \
            "$commit_date" "$commit_date" "$commit_author" "$commit_base_url/$commit_hash" "$commit_message"
    done)
}

# Function to check if a command exists
check_command() {
    cmd="$1"
    command -v "$cmd" > /dev/null 2>&1 || {
        printf "Error: %s is not installed or not in PATH. Please install it before running the script.\n" "$cmd"
        exit 1
    }
}

# Function to check if a variable is empty
check_var() {
    var_name="$1"
    # Use eval to fetch the value of the variable dynamically
    eval var_value=\$"$var_name"

    # Exit with an error message if the variable is empty
    [ -n "$var_value" ] || {
        printf "ERROR: The '%s' variable is not set or is empty. Exiting.\n" "$var_name"
        exit 1
    }
}

# List of required commands
required_commands="pandoc curl git realpath"

# Dynamically check each command
for cmd in $required_commands; do
    check_command "$cmd"
done

CONF_FILE=./conf
# shellcheck source=./conf
# shellcheck disable=SC2015
[ -f "$CONF_FILE" ] && . "$CONF_FILE" || {
    printf "ERROR: Configuration file (%s) not found. Exiting.\n" "$CONF_FILE"
    exit 1
}

# List of required variables
required_vars="BUILD_DIR CSS_FILE PICS_DIR GITHUB_REPO GITHUB_USER to_build default_header default_footer"

# Dynamically check each variable
for var in $required_vars; do
    check_var "$var"
done

[ -d "$BUILD_DIR" ] && rm -rf "$BUILD_DIR" # Delete build dir if it exists.
mkdir -p "$BUILD_DIR"

printf "%s" "$to_build" | while IFS= read -r file; do
    # Skip empty lines
    [ -n "$file" ] || continue
    ( # Subshell to maintain file-specific variables.
        file=$(realpath "$file")
        file_name=$(basename "$file")
        file_ext="${file_name##*.}"
        file_wext=${file_name%.*}

        [ ! -d "$file" ] && {
            printf "ERROR: %s doesn't exist.\n" "$file"
            exit 1
        }

        touch "$BUILD_DIR/$file_name"

        printf "Started generating => %s/%s\n" "$BUILD_DIR" "$file_name"

        # Source file-specific conf
        [ -f "$file/conf" ] && . "$file/conf"

        # Write default header if applicable
        [ "$file_ext" = "html" ] && {
            # shellcheck disable=SC2154,2015
            [ "$add_header" != "false" ] \
                && [ -f "$default_header" ] && {
                # Append the default header
                cat "$(realpath "$default_header")" >> "$BUILD_DIR/$file_name"
            } || {
                printf "ERROR: The default header file '%s' does not exist. Exiting.\n" "$default_header"
                exit 1
            }
        }

        # Write extension files if they exist
        for ext_file in "$file"/*."$file_ext"; do
            # Log the attempt to append the content
            printf "Appending content from %s to %s\n" "$ext_file" "$BUILD_DIR/$file_name"

            # Append the content of the extension file to the main file (only if it exists)
            cat "$ext_file" >> "$BUILD_DIR/$file_name" 2> /dev/null || printf "WARNING: No such file %s found\n" "$ext_file"
        done

        # Convert markdown to html if applicable
        [ "$file_ext" = "html" ] && [ -n "$is_markdown" ] && [ "$is_markdown" = "true" ] && {
            for md in "$file"/*.md; do
                [ -e "$md" ] || continue
                converted_md=$(pandoc "$md")
                # Replace or append the converted markdown content after the <!-- markdown --> comment
                replace "$BUILD_DIR/$file_name" "MARKDOWN" "$converted_md" "true"
                printf "Markdown file %s successfully converted to HTML using pandoc and aggregated into %s\n" "$md" "$BUILD_DIR/$file_name"
            done
        }

        # Aggregate CSS files
        [ "$file_ext" = "html" ] && {
            for css in "$file"/*.css; do
                [ -e "$css" ] || continue
                # Concatenate all .css files into the target CSS file
                cat "$css" >> "$BUILD_DIR/$file_wext.css"

                # Generate the <link> tag for inclusion in the HTML
                stylesheet="<link rel=\"stylesheet\" type=\"text/css\" href=\"$file_wext.css\">"

                # Replace the placeholder in the HTML file
                replace "$BUILD_DIR/$file_name" "HEAD" "$stylesheet" "true"

                # Log the aggregation process
                printf "Aggregated CSS files into %s\n" "$BUILD_DIR/$file_wext.css"
            done
        }

        # Write default footer if applicable
        [ "$file_ext" = "html" ] && {
            [ -z "$add_footer" ] || [ "$add_footer" = "true" ]
        } && cat "$(realpath "$default_footer")" >> "$BUILD_DIR/$file_name"

        # Extract and process placeholders
        placeholders=$(extract_placeholders "$BUILD_DIR/$file_name")

        # Get git info
        get_git_info "$file_name"

        for key in $placeholders; do
            eval val=\$"$key"

            # Handle git-derived values or warn about undefined placeholders
            case "$key" in
                # If not set explicitly, get from Git metadata
                date_created | date_updated)
                    [ -z "$val" ] && {
                        val=$([ "$key" = "date_created" ] && printf "%s" "$git_creation_date" || printf "%s" "$git_modification_date")
                        log_msg=$([ "$key" = "date_created" ] && printf "%s" "creation date" || printf "%s" "modification date")
                        printf "Replacing placeholder/key \"%s\" with git-derived %s => \"%s\" in %s (value not available in config to override)\n" "$key" "$log_msg" "$val" "$file_name"
                    }
                    ;;
                *)
                    [ -z "$val" ] && printf "WARNING: Placeholder \"%s\" has no value.\n" "$key"
                    ;;
            esac

            # Replace the placeholder in the file
            printf "Replacing placeholder/key \"%s\" with value => \"%s\" in %s\n" "$key" "$val" "$file_name"
            replace "$BUILD_DIR/$file_name" "$key" "$val" "false"
        done

        # Link file to index.html if link_index is true and file_name is not index.html
        [ "$file_name" != "index.html" ] && [ "$link_index" = "true" ] && {
            # Prepare the content to append to the <!-- POSTS --> comment in index.html
            # shellcheck disable=SC2154
            post_content="<li><time datetime=\"$date_created\">$date_created</time> &ndash; <a href=\"$file_name\">$title</a></li>"

            # Use replace to append the post content after the <!-- POSTS --> comment in index.html
            replace "$BUILD_DIR/index.html" "POSTS" "$post_content" "true"
            printf "File linked in index.html => %s\n" "$site_url/$file_name"
        }

        # Link file to rss.xml if link_rss is set to true
        [ "$file_name" != "rss.xml" ] && [ "$link_rss" = "true" ] && {
            # Prepare the content to append to the <!-- POSTS --> comment in rss.xml
            rss_content="<item><title>$title</title><guid>$site_url/$file_name</guid><pubDate>$date_created</pubDate><link>$site_url/$file_name</link><description>${description:-""}</description></item>"

            # Use replace to append the rss content after the <!-- POSTS --> comment in rss.xml
            replace "$BUILD_DIR/rss.xml" "POSTS" "$rss_content" "true"
            printf "File linked in RSS feed => %s\n" "$site_url/$file_name"
        }

        printf "Finished generating %s\n\n" "$BUILD_DIR/$file_name"
    ) # Subshell to maintain file-specific variables.
done

# This will get info for the whole repository.
get_git_info "."

# Replace comment in index.html with commit info
replace "$BUILD_DIR/index.html" "GIT" "$(printf "%s" "$all_commits" | head -n "$COMMITS_NUM")" "true"

# Copy CSS and images
cp "$CSS_FILE" "$BUILD_DIR"
cp -R "$PICS_DIR" "$BUILD_DIR"

#!/bin/sh
# shellcheck disable=SC2031

CONF_FILE=./conf

replace_placeholder() {
    DELIM=$(printf "\001") # Rare sed delimiter to avoid conflicts

    # Escape special characters in the replacement string to make it safe for sed
    REPLACE=$(printf "%s" "$2" | sed 's/[&/\]/\\&/g')

    # Convert newlines into a placeholder sequence (e.g., '\n') using tr
    REPLACE=$(printf "%s" "$REPLACE" | tr '\n' '\\n')

    # Ensure REPLACE is not empty
    if [ -z "$REPLACE" ]; then
        printf "Skipping replacement for placeholder \"%s\" because the replacement value is empty or invalid.\n" "$1"
        return
    fi

    # Use a harmless backup extension (e.g., .bak) to ensure compatibility with both BSD and GNU sed
    sed -i.bak "s${DELIM}\${$1}${DELIM}${REPLACE}${DELIM}g" "$BUILD_DIR/$file_name"

    # Remove the backup file as not needed
    rm -f "$BUILD_DIR/$file_name.bak"
}

# Function to replace or append <!-- %s ---> comments, without sed.
replace_comment() {
    file="$1"
    comment="$2"
    replacement="$3"
    append="$4"

    temp_file=$(mktemp)

    while IFS= read -r line; do
        # shellcheck disable=SC2015
        echo "$line" | grep -q "<!-- $comment -->" && {
            if [ "$append" = "true" ]; then
                echo "$line" >> "$temp_file"
                echo "$replacement" >> "$temp_file"
            else
                echo "$replacement" >> "$temp_file"
            fi
        } || {
            echo "$line" >> "$temp_file"
        }
    done < "$file"

    mv "$temp_file" "$file"
    printf "Processed comment \"<!-- %s -->\" in %s\n" "$comment" "$file"
}

get_git_info() {
    target="$1"

    # Get the commit logs.
    git_info=$(git log --format='%ad|%h|%an|%s' --date=rfc -- "$target")

    git_creation_info=$(echo "$git_info" | tail -n 1)
    git_modification_info=$(echo "$git_info" | head -n 1)

    git_creation_hash=$(echo "$git_creation_info" | cut -d'|' -f2)
    git_creation_date=$(echo "$git_creation_info" | cut -d'|' -f1)

    git_modification_hash=$(echo "$git_modification_info" | cut -d'|' -f2)
    git_modification_date=$(echo "$git_modification_info" | cut -d'|' -f1)

    # shellcheck disable=SC2034
    git_creation_author=$(echo "$git_creation_info" | cut -d'|' -f3)
    # shellcheck disable=SC2034
    git_modification_author=$(echo "$git_modification_info" | cut -d'|' -f3)

    commit_base_url="https://github.com/$GITHUB_USER/$GITHUB_REPO/commit"
    # shellcheck disable=SC2034
    git_creation_commit_link="$commit_base_url/$git_creation_hash"
    # shellcheck disable=SC2034
    git_modification_commit_link="$commit_base_url/$git_modification_hash"

    # Generate all commits list with newline after each entry
    all_commits=$(echo "$git_info" | while IFS='|' read -r commit_date commit_hash commit_author commit_message; do
        commit_url="$commit_base_url/$commit_hash"
        printf "<li><time datetime=\"%s\">%s</time> &ndash; <strong>%s</strong>: <a target=\"_blank\" href=\"%s\">%s</a></li>\n" \
            "$commit_date" "$commit_date" "$commit_author" "$commit_url" "$commit_message"
    done)
}

# Function to check if a command exists
check_command() {
    cmd="$1"
    command -v "$cmd" > /dev/null 2>&1 || {
        printf "Error: %s is not installed or not in PATH. Please install it before running the script.\n" "$cmd"
        exit 1
    }
}

# List of required commands
required_commands="jq pandoc curl git sed realpath"

# Dynamically check each command
for cmd in $required_commands; do
    check_command "$cmd"
done

# shellcheck disable=SC2015
# shellcheck source=./conf
[ -f "$CONF_FILE" ] && . "$CONF_FILE" || {
    printf "ERROR: Configuration file (%s) not found. Exiting.\n" "$CONF_FILE"
    exit 1
}

# Ensure critical variables are set
BUILD_DIR=${BUILD_DIR:-"./build"}
CSS_FILE=${CSS_FILE:-"./style.css"}
PICS_DIR=${PICS_DIR:-"./pics"}

# Ensure 'to_build' is set and not empty
[ -z "${to_build:-}" ] && {
    printf "ERROR: The 'to_build' variable is not set in the configuration file. Exiting.\n"
    exit 1
}

[ -d "$BUILD_DIR" ] && rm -rf "$BUILD_DIR" # Delete build dir if it exists
mkdir -p "$BUILD_DIR"

for file in $(printf "%s" "$to_build" | sed '/^$/d'); do
    ( # Subshell to maintain file-specific variables.
        file=$(realpath "$file")
        file_name=$(basename "$file")
        file_ext="${file_name##*.}"
        file_wext=${file_name%.*}

        [ ! -d "$file" ] && {
            printf "ERROR: %s doesn't exist.\n" "$file"
            exit 1
        }

        touch "$BUILD_DIR/$file_name"

        printf "Started generating => %s/%s\n" "$BUILD_DIR" "$file_name"

        # Source file-specific conf
        [ -f "$file/conf" ] && . "$file/conf"

        # Write default header if applicable
        [ "$file_ext" = "html" ] && {
            [ -z "$add_header" ] || [ "$add_header" = "true" ]
        } && cat "$(realpath "$default_header")" >> "$BUILD_DIR/$file_name"

        # Write external files if exist
        for ext_file in "$file"/*."$file_ext"; do
            cat "$ext_file" >> "$BUILD_DIR/$file_name"
        done

        # Convert Markdown to HTML if applicable
        [ "$file_ext" = "html" ] && [ -n "$is_markdown" ] && [ "$is_markdown" = "true" ] && {
            for md in "$(realpath "$file")"/*.md; do
                converted_md=$(pandoc "$md")
                # Replace or append the converted markdown content after the <!-- MARKDOWN --> comment
                replace_comment "$BUILD_DIR/$file_name" "MARKDOWN" "$converted_md" "true"
                printf "Markdown file %s successfully converted to HTML using Pandoc and aggregated into %s\n" "$BUILD_DIR/$file_name" "$md"
            done
        }

        # Aggregate CSS files if found
        for css in "$(realpath "$file")"/*.css; do
            [ -f "$css" ] || continue # Skip if no CSS files found
            cat "$css" >> "$BUILD_DIR/$file_wext.css"
            stylesheet="<link rel=\"stylesheet\" type=\"text/css\" href=\"$file_wext.css\">"

            replace_comment "$BUILD_DIR/$file_name" "HEAD" "$stylesheet" "true"
            printf "Aggregated %s into %s\n" "$css" "$BUILD_DIR/$file_wext.css"
        done

        # Write default footer if applicable
        [ "$file_ext" = "html" ] && {
            [ -z "$add_footer" ] || [ "$add_footer" = "true" ]
        } && cat "$(realpath "$default_footer")" >> "$BUILD_DIR/$file_name"

        # Extract and process placeholders
        placeholders=$(grep -o "\${\([^}]*\)}" "$BUILD_DIR/$file_name" | sed 's/[${}]//g' | sort -u)

        # Get git info
        get_git_info "$file_name"

        for key in $placeholders; do
            eval val=\$"$key"

            # Handle git-derived values or warn about undefined placeholders
            case "$key" in
                date_created | date_updated)
                    [ -z "$val" ] && {
                        val=$([ "$key" = "date_created" ] && printf "%s" "$git_creation_date" || printf "%s" "$git_modification_date")
                        log_msg=$([ "$key" = "date_created" ] && printf "%s" "creation date" || printf "%s" "modification date")
                        printf "Replacing placeholder/key \"%s\" with git-derived %s => \"%s\" in %s (value not available in config to override)\n" "$key" "$log_msg" "$val" "$file_name"
                    }
                    ;;
                *)
                    [ -z "$val" ] && printf "WARNING: Placeholder \"%s\" has no value.\n" "$key"
                    ;;
            esac

            # Replace the placeholder in the file
            printf "Replacing placeholder/key \"%s\" with value => \"%s\" in %s\n" "$key" "$val" "$file_name"
            replace_placeholder "$key" "$val" "$BUILD_DIR/$file_name"
        done

        # Link file to index.html if necessary
        link_index=${link_index:-"false"}
        link_rss=${link_rss:-"false"}
        date_created=${date_created:-""}
        title=${title:-"Untitled"}

        # Link file to index.html if link_index is true and file_name is not index.html
        [ "$file_name" != "index.html" ] && [ "$link_index" = "true" ] && {
            # Prepare the content to append to the <!-- POSTS --> comment in index.html
            post_content="<li><time datetime=\"$date_created\">$date_created</time> &ndash; <a href=\"$file_name\">$title</a></li>"

            # Use replace_comment to append the post content after the <!-- POSTS --> comment in index.html
            replace_comment "$BUILD_DIR/index.html" "POSTS" "$post_content" "true"
            printf "File linked in index.html => %s\n" "$site_url/$file_name"
        }

        # Link file to rss.xml if necessary
        [ "$file_name" != "rss.xml" ] && [ "$link_rss" = "true" ] && {
            # Prepare the content to append to the <!-- POSTS --> comment in rss.xml
            rss_content="<item>\n<title>$title</title>\n<guid>$site_url/$file_name</guid>\n<pubDate>$date_created</pubDate>\n<link>$site_url/$file_name</link>\n<description>${description:-""}</description>\n</item>"

            # Use replace_comment to append the rss content after the <!-- POSTS --> comment in rss.xml
            replace_comment "$BUILD_DIR/rss.xml" "POSTS" "$rss_content" "true"
            printf "File linked in RSS feed => %s\n" "$site_url/$file_name"
        }

        printf "Finished generating %s\n\n" "$BUILD_DIR/$file_name"
    ) # Subshell to maintain file-specific variables.
done

# This will get info for the whole repository.
get_git_info "."

# Replace comment in index.html with commit info
replace_comment "$BUILD_DIR/index.html" "GIT" "$(printf "%s" "$all_commits" | head -n "$COMMITS_NUM")" "true"

# Copy CSS and images
cp "$CSS_FILE" "$BUILD_DIR"
cp -r "$PICS_DIR" "$BUILD_DIR"
